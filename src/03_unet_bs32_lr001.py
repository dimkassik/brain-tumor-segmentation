# -*- coding: utf-8 -*-
"""03_unet_bs32_lr001.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7pT3z68RepH5j_QdK6P_uzqjZ8-wy6X
"""

import os
import numpy as np
import cv2
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import Input, Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Conv2DTranspose, Concatenate
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau
from sklearn.model_selection import train_test_split
import random

# ===========================
# НАСТРОЙКИ (ОПТИМАЛЬНЫЕ)
# ===========================
IMG_SIZE = 128
EPOCHS = 100
BATCH_SIZE = 32
LR = 1e-3
DATASET_PATH = "kaggle_3m"

MODEL_NAME = "Best_UNet_LR0.001_BS32"
MODEL_PATH = f"{MODEL_NAME}.keras"

# ===========================
# МЕТРИКИ
# ===========================
def dice_coef(y_true, y_pred, smooth=1e-6):
    y_pred = tf.cast(y_pred > 0.5, tf.float32)
    intersection = tf.reduce_sum(y_true * y_pred)
    return (2. * intersection + smooth) / (
        tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) + smooth
    )

def iou_coef(y_true, y_pred, smooth=1e-6):
    y_pred = tf.cast(y_pred > 0.5, tf.float32)
    intersection = tf.reduce_sum(y_true * y_pred)
    union = tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) - intersection
    return (intersection + smooth) / (union + smooth)

def dice_loss(y_true, y_pred):
    smooth = 1e-6
    intersection = tf.reduce_sum(y_true * y_pred)
    return 1 - (2. * intersection + smooth) / (
        tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) + smooth
    )

def bce_dice_loss(y_true, y_pred):
    bce = tf.keras.losses.BinaryCrossentropy()(y_true, y_pred)
    return bce + dice_loss(y_true, y_pred)

# ===========================
# ЗАГРУЗКА ДАННЫХ
# ===========================
def load_data(dataset_path):
    images, masks = [], []
    patient_folders = [
        os.path.join(dataset_path, f)
        for f in os.listdir(dataset_path)
        if os.path.isdir(os.path.join(dataset_path, f))
    ]

    for folder in patient_folders:
        for file in os.listdir(folder):
            if file.endswith(".tif") and "mask" not in file:
                img_path = os.path.join(folder, file)
                mask_path = img_path.replace(".tif", "_mask.tif")
                if not os.path.exists(mask_path):
                    continue

                img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
                img = cv2.resize(img, (IMG_SIZE, IMG_SIZE)) / 255.0
                img = np.expand_dims(img, -1)

                mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
                mask = cv2.resize(mask, (IMG_SIZE, IMG_SIZE))
                mask = (mask > 127).astype(np.float32)
                mask = np.expand_dims(mask, -1)

                images.append(img)
                masks.append(mask)

    images = np.array(images, dtype=np.float32)
    masks = np.array(masks, dtype=np.float32)
    print(f"Loaded dataset: {images.shape}, {masks.shape}")
    return images, masks

print("Loading dataset...")
X, y = load_data(DATASET_PATH)
X_train, X_val, y_train, y_val = train_test_split(
    X, y, test_size=0.1, random_state=42
)

# ===========================
# U-NET
# ===========================
def unet():
    inputs = Input((IMG_SIZE, IMG_SIZE, 1))

    c1 = Conv2D(16, 3, activation="relu", padding="same")(inputs)
    c1 = Conv2D(16, 3, activation="relu", padding="same")(c1)
    p1 = MaxPooling2D()(c1)

    c2 = Conv2D(32, 3, activation="relu", padding="same")(p1)
    c2 = Conv2D(32, 3, activation="relu", padding="same")(c2)
    p2 = MaxPooling2D()(c2)

    c3 = Conv2D(64, 3, activation="relu", padding="same")(p2)
    c3 = Conv2D(64, 3, activation="relu", padding="same")(c3)

    u2 = Conv2DTranspose(32, 2, strides=2, padding="same")(c3)
    u2 = Concatenate()([u2, c2])
    c4 = Conv2D(32, 3, activation="relu", padding="same")(u2)
    c4 = Conv2D(32, 3, activation="relu", padding="same")(c4)

    u3 = Conv2DTranspose(16, 2, strides=2, padding="same")(c4)
    u3 = Concatenate()([u3, c1])
    c5 = Conv2D(16, 3, activation="relu", padding="same")(u3)

    outputs = Conv2D(1, 1, activation="sigmoid")(c5)
    return Model(inputs, outputs)

# ===========================
# CALLBACKS
# ===========================
callbacks = [
    EarlyStopping(
        monitor="val_dice_coef",
        patience=15,
        mode="max",
        restore_best_weights=True,
        verbose=1
    ),
    ReduceLROnPlateau(
        monitor="val_dice_coef",
        factor=0.5,
        patience=7,
        min_lr=1e-6,
        mode="max",
        verbose=1
    ),
    ModelCheckpoint(
        MODEL_PATH,
        monitor="val_dice_coef",
        save_best_only=True,
        mode="max",
        verbose=1
    )
]

# ===========================
# ОБУЧЕНИЕ
# ===========================
tf.keras.backend.clear_session()

model = unet()
model.compile(
    optimizer=Adam(LR),
    loss=bce_dice_loss,
    metrics=[dice_coef, iou_coef]
)

history = model.fit(
    X_train, y_train,
    validation_data=(X_val, y_val),
    epochs=EPOCHS,
    batch_size=BATCH_SIZE,
    callbacks=callbacks,
    verbose=1
)

# ===========================
# ГРАФИКИ
# ===========================
def plot_metric(metric, ylabel):
    plt.figure(figsize=(8, 4))
    plt.plot(history.history[metric], label="Train")
    plt.plot(history.history["val_" + metric], label="Val")
    plt.xlabel("Epoch")
    plt.ylabel(ylabel)
    plt.title(metric)
    plt.legend()
    plt.tight_layout()
    plt.savefig(f"{MODEL_NAME}_{metric}.png")
    plt.close()

plot_metric("loss", "Loss")
plot_metric("dice_coef", "Dice")
plot_metric("iou_coef", "IoU")

print("Training complete. All graphs saved.")

# ===========================
# ВИЗУАЛИЗАЦИЯ ПРЕДСКАЗАНИЯ
# ===========================
idx = random.randint(0, len(X_val) - 1)
img = X_val[idx]
mask = y_val[idx]
pred = model.predict(img[np.newaxis])[0]

plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.title("Image")
plt.imshow(img[:, :, 0], cmap="gray")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.title("GT Mask")
plt.imshow(mask[:, :, 0], cmap="gray")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.title("Prediction")
plt.imshow(pred[:, :, 0] > 0.5, cmap="gray")
plt.axis("off")

plt.tight_layout()
plt.savefig(f"{MODEL_NAME}_prediction.png")
plt.close()