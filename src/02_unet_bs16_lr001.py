# -*- coding: utf-8 -*-
"""02_unet_bs16_lr001.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7pT3z68RepH5j_QdK6P_uzqjZ8-wy6X
"""

import os
import numpy as np
import cv2
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import Input, Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Conv2DTranspose, Concatenate
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
from sklearn.model_selection import train_test_split
import random

# ===========================
# НАСТРОЙКИ (ФИНАЛ)
# ===========================
IMG_SIZE = 128
EPOCHS = 100
BATCH_SIZE = 16
LR = 1e-3
DATASET_PATH = "kaggle_3m"

MODEL_NAME = "U-Net_LR0.001_BS16_FINAL.keras"
PRED_NAME = "U-Net_LR0.001_BS16_FINAL_prediction.png"

# ===========================
# Метрики
# ===========================
def dice_coef(y_true, y_pred, smooth=1e-6):
    y_pred = tf.cast(y_pred > 0.5, tf.float32)
    intersection = tf.reduce_sum(y_true * y_pred)
    return (2. * intersection + smooth) / (
        tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) + smooth
    )

def iou_coef(y_true, y_pred, smooth=1e-6):
    y_pred = tf.cast(y_pred > 0.5, tf.float32)
    intersection = tf.reduce_sum(y_true * y_pred)
    union = tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) - intersection
    return (intersection + smooth) / (union + smooth)

def dice_loss(y_true, y_pred):
    return 1 - dice_coef(y_true, y_pred)

def bce_dice_loss(y_true, y_pred):
    bce = tf.keras.losses.BinaryCrossentropy()(y_true, y_pred)
    return bce + dice_loss(y_true, y_pred)

# ===========================
# Загрузка данных
# ===========================
def load_data(dataset_path, img_size=IMG_SIZE):
    images, masks = [], []
    for folder in os.listdir(dataset_path):
        folder_path = os.path.join(dataset_path, folder)
        if not os.path.isdir(folder_path):
            continue

        for file in os.listdir(folder_path):
            if file.endswith(".tif") and "mask" not in file:
                img_path = os.path.join(folder_path, file)
                mask_path = img_path.replace(".tif", "_mask.tif")
                if not os.path.exists(mask_path):
                    continue

                img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
                img = cv2.resize(img, (img_size, img_size)) / 255.0
                img = img[..., np.newaxis]

                mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
                mask = cv2.resize(mask, (img_size, img_size))
                mask = (mask > 127).astype(np.float32)
                mask = mask[..., np.newaxis]

                images.append(img)
                masks.append(mask)

    return np.array(images, dtype=np.float32), np.array(masks, dtype=np.float32)

print("Loading dataset...")
X, y = load_data(DATASET_PATH)
X_train, X_val, y_train, y_val = train_test_split(
    X, y, test_size=0.1, random_state=42
)

# ===========================
# U-Net
# ===========================
def unet(input_size=(IMG_SIZE, IMG_SIZE, 1)):
    inputs = Input(input_size)

    c1 = Conv2D(16, 3, activation="relu", padding="same")(inputs)
    c1 = Conv2D(16, 3, activation="relu", padding="same")(c1)
    p1 = MaxPooling2D()(c1)

    c2 = Conv2D(32, 3, activation="relu", padding="same")(p1)
    c2 = Conv2D(32, 3, activation="relu", padding="same")(c2)
    p2 = MaxPooling2D()(c2)

    c3 = Conv2D(64, 3, activation="relu", padding="same")(p2)
    c3 = Conv2D(64, 3, activation="relu", padding="same")(c3)

    u2 = Conv2DTranspose(32, 2, strides=2, padding="same")(c3)
    u2 = Concatenate()([u2, c2])
    c4 = Conv2D(32, 3, activation="relu", padding="same")(u2)
    c4 = Conv2D(32, 3, activation="relu", padding="same")(c4)

    u3 = Conv2DTranspose(16, 2, strides=2, padding="same")(c4)
    u3 = Concatenate()([u3, c1])
    c5 = Conv2D(16, 3, activation="relu", padding="same")(u3)

    outputs = Conv2D(1, 1, activation="sigmoid")(c5)
    return Model(inputs, outputs)


# ===========================
# Компиляция
# ===========================
model = unet()
model.compile(
    optimizer=Adam(LR),
    loss=bce_dice_loss,
    metrics=[dice_coef, iou_coef]
)

# ===========================
# Callbacks
# ===========================
callbacks = [
    EarlyStopping(monitor="val_dice_coef", patience=15, mode="max", restore_best_weights=True),
    ReduceLROnPlateau(monitor="val_loss", factor=0.5, patience=7, min_lr=1e-6),
    ModelCheckpoint(MODEL_NAME, monitor="val_dice_coef", mode="max", save_best_only=True)
]

# ===========================
# Обучение
# ===========================
history = model.fit(
    X_train, y_train,
    validation_data=(X_val, y_val),
    epochs=EPOCHS,
    batch_size=BATCH_SIZE,
    callbacks=callbacks,
    verbose=1
)

# ===========================
# Графики
# ===========================
def plot_metric(metric, title):
    plt.figure(figsize=(8, 4))
    plt.plot(history.history[metric], label=f"Train {metric}")
    plt.plot(history.history[f"val_{metric}"], label=f"Val {metric}")
    plt.title(title)
    plt.xlabel("Epochs")
    plt.legend()
    plt.tight_layout()
    plt.savefig(f"{metric}_FINAL.png")
    plt.close()

plot_metric("dice_coef", "Dice coefficient")
plot_metric("iou_coef", "IoU")
plot_metric("loss", "Loss")

# ===========================
# Пример предсказания
# ===========================
idx = random.randint(0, len(X_val) - 1)
pred = model.predict(X_val[idx:idx+1])[0]

plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.title("Input")
plt.imshow(X_val[idx, :, :, 0], cmap="gray")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.title("Ground Truth")
plt.imshow(y_val[idx, :, :, 0], cmap="gray")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.title("Prediction")
plt.imshow(pred[:, :, 0] > 0.5, cmap="gray")
plt.axis("off")

plt.tight_layout()
plt.savefig(PRED_NAME)
plt.close()

print("✅ Training finished. Best model saved.")